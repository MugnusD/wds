function findOrThrow(arr, p) {
    const result = arr.find(p);
    if (result === undefined)
        throw new Error('object not found');
    return result;
}
function getOrThrow(map, key) {
    const value = map.get(key);
    if (value === undefined)
        throw new Error('key not found');
    return value;
}
function getOrDefault(map, key, defaultValue) {
    const value = map.get(key);
    if (value === undefined)
        return defaultValue;
    return value;
}

class GithubMasterProvider {
    async getMasterData(key) {
        const res = await fetch(`https://raw.githubusercontent.com/xfl03/sirius-master/main/${key}.json`);
        const json = await res.json();
        return json;
    }
    async getMasterDataById(key, id) {
        return findOrThrow(await this.getMasterData(key), it => it.id === id);
    }
}

class CachedDataProvider {
    dataProvider;
    constructor(dataProvider) {
        this.dataProvider = dataProvider;
    }
    static globalCache = new Map();
    static runningPromise = new Map();
    async getData(cache, cacheKey, promise) {
        if (cache.has(cacheKey))
            return cache.get(cacheKey);
        while (CachedDataProvider.runningPromise.has(cacheKey)) {
            await CachedDataProvider.runningPromise.get(cacheKey);
        }
        if (cache.has(cacheKey))
            return cache.get(cacheKey);
        CachedDataProvider.runningPromise.set(cacheKey, promise());
        const data = await getOrThrow(CachedDataProvider.runningPromise, cacheKey).then(data => {
            cache.set(cacheKey, data);
            return data;
        });
        CachedDataProvider.runningPromise.delete(cacheKey);
        return data;
    }
    async getMasterData(key) {
        return await this.getData(CachedDataProvider.globalCache, key, async () => await this.dataProvider.getMasterData(key));
    }
    static idMapCache = new Map();
    async getMasterDataById(key, id) {
        if (!CachedDataProvider.idMapCache.has(key)) {
            const map = new Map();
            const arr = await this.getMasterData(key);
            arr.forEach(it => map.set(it.id, it));
            CachedDataProvider.idMapCache.set(key, map);
        }
        return getOrThrow(getOrThrow(CachedDataProvider.idMapCache, key), id);
    }
}

class DataProviderFactory {
    static defaultDataProvider() {
        return new CachedDataProvider(new GithubMasterProvider());
    }
}

class CharacterBaseService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getCharacterBase(id) {
        return await this.dataProvider.getMasterDataById('characterBase', id);
    }
    async getCharacterBaseName(id) {
        const characterBase = await this.getCharacterBase(id);
        return characterBase.name;
    }
}

function toFixedString(num, fractionDigits = 1) {
    return num.toFixed(fractionDigits).replace(/\.0+$/, '');
}
function toRangeString(from, to) {
    return from === to ? toFixedString(from) : `${toFixedString(from)}~${toFixedString(to)}`;
}

class EffectService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getEffect(id) {
        return await this.dataProvider.getMasterDataById('effect', id);
    }
    async getEffects(ids) {
        return await Promise.all(ids.map(async (it) => await this.getEffect(it)));
    }
    getEffectDetail(effect, level) {
        const div = ['PercentageAddition', 'Multiplication'].includes(effect.calculationType) ? 100 : 1;
        const detail = findOrThrow(effect.details, it => it.level === level);
        return detail.value / div;
    }
    async getEffectRange(id, from = 1, to = 114514) {
        const effect = await this.getEffect(id);
        to = Math.min(effect.details.length, to);
        const f = this.getEffectDetail(effect, from);
        const t = this.getEffectDetail(effect, to);
        return toRangeString(f, t);
    }
    async getEffectDurationSecond(id) {
        const effect = await this.getEffect(id);
        return effect.durationSecond;
    }
}

const effectTranslations = [{
        japanese: '[:gauge]のプリンシパルゲージを獲得',
        chinese: '获得[:gauge]点Principle Gauge'
    }, {
        japanese: '[:score]倍のスコアを獲得',
        chinese: '获得自身演技力[:score]倍的分数'
    }, {
        japanese: '[:sec]秒間、[COMPANY]のアクターにスターアクトスコア[:param11]％UP効果',
        chinese: '[:sec]秒内，[COMPANY]的演员Sense中获得的分数提升[:param11]'
    }, {
        japanese: '[:sec]秒間、[COMPANY]のアクターにセンススコア[:param11]％UP効果',
        chinese: '[:sec]秒内，[COMPANY]的演员Star Act中获得的分数提升[:param11]'
    }, {
        japanese: '[COMPANY]のアクターのCTを[TIME]秒短縮',
        chinese: '[COMPANY]的演员CT缩短[TIME]秒'
    }, {
        japanese: '[CHARACTER]のCTを[TIME]秒短縮',
        chinese: '[CHARACTER]的CT缩短[TIME]秒'
    }, {
        japanese: 'ここな編成時、ここなが代わりにセンスを発動し、ここなのスコア獲得量[:pre1]％UP',
        chinese: '队伍中有凤心菜编成时，凤心菜代替发动Sense，同时使凤心菜的分数获得量提高[:pre1]%'
    }, {
        japanese: 'ここな編成時、ここなが代わりにセンスを発動し、ここなのスコア獲得量[:pre2]％、スターアクトスコア獲得量[:pre3]％UP',
        chinese: '队伍中有凤心菜编成时，凤心菜代替发动Sense，同时使凤心菜的分数获得量提高[:pre2]%，Star Act分数获得量提升[:pre3]%'
    }, {
        japanese: 'センス発動後、追加で[:param11]のプリンシパルゲージを獲得',
        chinese: 'Sense发动后，追加获得[:param11]点P.计量槽'
    }, {
        japanese: 'ライフが多いほど[CHARACTER]のスコア獲得量UP（最大＋100％）',
        chinese: '血量越多，[CHARACTER]的分数获得量越高（最大+100％）'
    }, {
        japanese: 'ライフが少ないほど[CHARACTER]のスコア獲得量UP（最大+100％）',
        chinese: '血量越少，[CHARACTER]的分数获得量越高（最大+100％）'
    }, {
        japanese: 'ライフを[:param11]回復',
        chinese: '回复[:param11]点血量'
    }, {
        japanese: '効果無し（所持している「光」は維持される）',
        chinese: '无效果（维持目前所拥有的光）'
    }, {
        japanese: '総演技力の[:score]倍のスコアを獲得',
        chinese: '获得总演技力[:score]倍的分数'
    }];
const effectTimes = [1, 2, 3, 5, 8, 9, 10];

const characterBaseChineseNames = {
    101: '凤心菜',
    102: '静香',
    103: '卡特莉娜·格利贝尔',
    104: '新妻八惠',
    105: '柳场潘达',
    106: '流石知冴',
    201: '连尺野初魅',
    202: '乌森大黑',
    203: '舍人仁花子',
    204: '万容',
    205: '笔岛时雨',
    301: '千寿历',
    302: '拉莫娜·沃尔芙',
    303: '王雪',
    304: '莉莉亚·库尔特贝',
    305: '与那国绯花里',
    401: '千寿伊吕波',
    402: '白丸美兔',
    403: '阿岐留卡米拉',
    404: '猫足蕾',
    405: '千寿伊吕波'
};
const characterBaseTranslations = [{
        japanese: 'ここな',
        chinese: '凤心菜'
    }, {
        japanese: '静香',
        chinese: '静香'
    }, {
        japanese: 'カトリナ・グリーベル',
        chinese: '卡特莉娜·格利贝尔'
    }, {
        japanese: '八恵',
        chinese: '新妻八惠'
    }, {
        japanese: 'ぱんだ',
        chinese: '柳场潘达'
    }, {
        japanese: '知冴',
        chinese: '流石知冴'
    }, {
        japanese: '初魅',
        chinese: '连尺野初魅'
    }, {
        japanese: '大黒',
        chinese: '乌森大黑'
    }, {
        japanese: '仁花子',
        chinese: '舍人仁花子'
    }, {
        japanese: '萬容',
        chinese: '万容'
    }, {
        japanese: 'しぐれ',
        chinese: '笔岛时雨'
    }, {
        japanese: '暦',
        chinese: '千寿历'
    }, {
        japanese: 'ラモーナ・ウォルフ',
        chinese: '拉莫娜·沃尔芙'
    }, {
        japanese: '王雪',
        chinese: '王雪'
    }, {
        japanese: 'リリヤ・クルトベイ',
        chinese: '莉莉亚·库尔特贝'
    }, {
        japanese: '緋花里',
        chinese: '与那国绯花里'
    }, {
        japanese: 'いろは',
        chinese: '千寿伊吕波'
    }, {
        japanese: '美兎',
        chinese: '白丸美兔'
    }, {
        japanese: 'カミラ',
        chinese: '阿岐留卡米拉'
    }, {
        japanese: '蕾',
        chinese: '猫足蕾'
    }, {
        japanese: '叶羽',
        chinese: '本巢叶羽'
    }];

const companyTranslations = [{
        japanese: 'シリウス',
        chinese: '天狼星'
    }, {
        japanese: 'Eden',
        chinese: 'Eden'
    }, {
        japanese: '銀河座',
        chinese: '银河座'
    }, {
        japanese: '劇団電姫',
        chinese: '剧团电姬'
    }];

const bloomTranslations = [{
        japanese: 'スターアクト発動に必要な[LIGHT]の光の個数が1個減少',
        chinese: 'Star Act发动所需要的[LIGHT]光个数减1'
    }, {
        japanese: 'センスのCTが[TIME]秒減少',
        chinese: 'Sense的CT缩短[TIME]秒'
    }, {
        japanese: '公演での報酬量が10％上昇',
        chinese: '公演的报酬量上升10%'
    }, {
        japanese: '初期プリンシパルゲージが[PG]上昇',
        chinese: '初始Principle Gauge上升[PG]'
    }, {
        japanese: '初期ライフが[LIFE]上昇',
        chinese: '初始血量上升[LIFE]'
    }, {
        japanese: '基礎スコアが[SCORE]％上昇',
        chinese: '基础分数提升[SCORE]%'
    }, {
        japanese: '演技力[STATUS]％UP',
        chinese: '演技力上升[STATUS]%'
    }];
const bloomPrincipleGaugeBonuses = [20, 30, 50];
const bloomLifeBonuses = [40, 60, 100];
const bloomScoreBonuses = [1, 2, 3, 5, 10];
const bloomStatusBonuses = [2, 3, 4, 6, 8, 12, 16, 18, 24];

const lightTranslations = [{
        japanese: '支援',
        chinese: '支援系'
    }, {
        japanese: '支配',
        chinese: '支配系'
    }, {
        japanese: '増幅',
        chinese: '增幅系'
    }, {
        japanese: '特殊',
        chinese: '特殊系'
    }];

class TranslationService {
    static translationService = new TranslationService();
    chineseTranslationMap = new Map();
    constructor() {
        this.buildChineseTranslationMap();
    }
    static getInstance() {
        return TranslationService.translationService;
    }
    addChineseTranslation(translation) {
        this.chineseTranslationMap.set(translation.japanese, translation.chinese);
    }
    dfsAddChineseTranslation(translation, replacements) {
        for (const key of replacements.keys()) {
            if (translation.japanese.includes(key)) {
                getOrThrow(replacements, key).forEach(replacement => {
                    const newTranslation = {
                        japanese: translation.japanese.replaceAll(key, replacement.japanese),
                        chinese: translation.chinese.replaceAll(key, replacement.chinese)
                    };
                    this.dfsAddChineseTranslation(newTranslation, replacements);
                });
                return;
            }
        }
        this.chineseTranslationMap.set(translation.japanese, translation.chinese);
    }
    static addReplacements(replacements, key, numbers) {
        replacements.set(key, numbers.map(it => { return { japanese: it.toString(), chinese: it.toString() }; }));
    }
    buildChineseTranslationMap() {
        if (this.chineseTranslationMap.size > 0) {
            return;
        }
        characterBaseTranslations.forEach(it => { this.addChineseTranslation(it); });
        companyTranslations.forEach(it => { this.addChineseTranslation(it); });
        const replacements = new Map();
        TranslationService.addReplacements(replacements, '[TIME]', effectTimes);
        TranslationService.addReplacements(replacements, '[PG]', bloomPrincipleGaugeBonuses);
        TranslationService.addReplacements(replacements, '[LIFE]', bloomLifeBonuses);
        TranslationService.addReplacements(replacements, '[SCORE]', bloomScoreBonuses);
        TranslationService.addReplacements(replacements, '[STATUS]', bloomStatusBonuses);
        replacements.set('[CHARACTER]', characterBaseTranslations);
        replacements.set('[COMPANY]', companyTranslations);
        replacements.set('[LIGHT]', lightTranslations);
        effectTranslations.forEach(it => { this.dfsAddChineseTranslation(it, replacements); });
        bloomTranslations.forEach(it => { this.dfsAddChineseTranslation(it, replacements); });
    }
    getChineseTranslation(japanese) {
        return getOrDefault(this.chineseTranslationMap, japanese, japanese);
    }
}

class CharacterBloomService {
    dataProvider;
    effectService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
    }
    async getCharacterBloomBonusGroup(id) {
        return await this.dataProvider.getMasterDataById('characterBloomBonusGroup', id);
    }
    async getBloomBonusTotal(id, type, bloom = 5) {
        const bonus = await this.getCharacterBloomBonusGroup(id);
        const effects = await this.effectService
            .getEffects(bonus.bloomBonuses.filter(it => it.phase <= bloom)
            .map(it => it.effectMasterId));
        return effects
            .filter(it => it.type === type)
            .map(it => it.details[0].value)
            .reduce((sum, it) => sum + it, 0);
    }
    async getBloomBonusDetails(id) {
        const bonuses = await this.getCharacterBloomBonusGroup(id);
        return Array.from(new Set(bonuses.bloomBonuses.map(it => it.phase)))
            .sort((a, b) => a - b).map(phase => {
            const descriptions = bonuses.bloomBonuses
                .filter(it => it.phase === phase)
                .map(it => it.description);
            return {
                phase,
                descriptions,
                descriptionsChinese: descriptions
                    .map(it => TranslationService.getInstance().getChineseTranslation(it))
            };
        });
    }
}

class SenseService {
    dataProvider;
    effectService;
    characterBloomService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
    }
    async getSense(id) {
        return await this.dataProvider.getMasterDataById('sense', id);
    }
    async getSenseDescription(sense, description) {
        for (let i = 0; i < sense.preEffects.length; ++i) {
            const effect = sense.preEffects[i];
            description = description.replaceAll(`[:pre${i + 1}]`, await this.effectService.getEffectRange(effect.effectMasterId, 1, 5));
        }
        for (let i = 0; i < sense.branches.length; ++i) {
            const branch = sense.branches[i];
            for (let j = 0; j < branch.branchEffects.length; ++j) {
                const effect = branch.branchEffects[i];
                description = description.replaceAll(`[:param${i + 1}${j + 1}]`, await this.effectService.getEffectRange(effect.effectMasterId, 1, 5));
                const durationSecond = await this.effectService.getEffectDurationSecond(effect.effectMasterId);
                if (durationSecond > 0) {
                    description = description.replaceAll('[:sec]', durationSecond.toString());
                }
            }
        }
        const gauge = sense.acquirableGauge;
        if (gauge > 0) {
            description = description.replaceAll('[:gauge]', gauge.toString());
        }
        const base = sense.acquirableScorePercent / 100;
        const level = sense.scoreUpPerLevel / 100;
        if (base > 0 || level > 0) {
            description = description.replaceAll('[:score]', toRangeString(base, base + level * 5));
        }
        return description;
    }
    async getSenseDetail(id, bloomBonusGroupId) {
        const sense = await this.getSense(id);
        const descriptions = await Promise.all(sense.description.split('／')
            .map(async (it) => await this.getSenseDescription(sense, it)));
        const descriptionsChinese = await Promise.all(sense.description.split('／')
            .map(it => TranslationService.getInstance().getChineseTranslation(it))
            .map(async (it) => await this.getSenseDescription(sense, it)));
        return {
            descriptions,
            descriptionsChinese,
            type: sense.type,
            lightCount: sense.lightCount,
            coolTime: {
                origin: sense.coolTime,
                bloom: sense.coolTime - await this.characterBloomService
                    .getBloomBonusTotal(bloomBonusGroupId, 'SenseRecastDown')
            }
        };
    }
}

const lights = [
    {
        type: 'Alternative',
        typeChinese: '任意系',
        typeChineseShort: '任意',
        condition: 'freeLight',
        decrease: 'DecreaseRequireAlternativeLight'
    },
    {
        type: 'Support',
        typeChinese: '支援系',
        typeChineseShort: '绿',
        condition: 'supportLight',
        decrease: 'DecreaseRequireSupportLight'
    },
    {
        type: 'Control',
        typeChinese: '支配系',
        typeChineseShort: '红',
        condition: 'controlLight',
        decrease: 'DecreaseRequireControlLight'
    },
    {
        type: 'Amplification',
        typeChinese: '增幅系',
        typeChineseShort: '黄',
        condition: 'amplificationLight',
        decrease: 'DecreaseRequireAmplificationLight'
    },
    {
        type: 'Special',
        typeChinese: '特殊系',
        typeChineseShort: '蓝',
        condition: 'specialLight',
        decrease: 'DecreaseRequireSpecialLight'
    }
];

class StarActService {
    dataProvider;
    effectService;
    characterBloomService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
    }
    async getStarAct(id) {
        return await this.dataProvider.getMasterDataById('starAct', id);
    }
    async getStarActCondition(id) {
        return await this.dataProvider.getMasterDataById('starActCondition', id);
    }
    async getStarActDetail(id, bloomBonusGroupId) {
        const starAct = await this.getStarAct(id);
        const base = starAct.acquirableScorePercent / 100;
        const level = starAct.scoreUpPerLevel / 100;
        const scoreRange = toRangeString(base, base + level * 5);
        const description = starAct.description
            .replaceAll('[:score]', scoreRange);
        const descriptionChinese = TranslationService.getInstance().getChineseTranslation(starAct.description)
            .replaceAll('[:score]', scoreRange);
        const condition = await this.getStarActCondition(starAct.starActConditionMasterId);
        const conditions = await Promise.all([condition.freeLight, condition.supportLight, condition.controlLight,
            condition.amplificationLight, condition.specialLight].map(async (it, i) => {
            const { type, typeChinese, decrease } = lights[i];
            return {
                type,
                typeChinese,
                origin: it,
                bloom: it - await this.characterBloomService.getBloomBonusTotal(bloomBonusGroupId, decrease)
            };
        }));
        return {
            description,
            descriptionChinese,
            conditions
        };
    }
}

function siriusTimestampToDate(timestamp) {
    return new Date(timestamp * 1000 - 9 * 3600 * 1000);
}

class CharacterCalculator {
    dataProvider;
    characterBloomService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.characterBloomService = new CharacterBloomService(dataProvider);
    }
    async getCharacterLevel(level) {
        const levels = await this.dataProvider.getMasterData('characterLevel');
        return findOrThrow(levels, it => it.level === level);
    }
    async getMaxCharacterLevel() {
        const levels = await this.dataProvider.getMasterData('characterLevel');
        return levels.filter(it => siriusTimestampToDate(it.startDate).getTime() <= Date.now())
            .reduce((max, it) => Math.max(max, it.level), 0);
    }
    static getEpisodeBonus(episode) {
        switch (episode) {
            case CharacterEpisodeStatus.NONE:
                return 0;
            case CharacterEpisodeStatus.FIRST:
                return 2;
            case CharacterEpisodeStatus.SECOND:
                return 5;
        }
    }
    static getStatus(base, levelBonus, bonus) {
        return Math.floor(base * levelBonus * bonus);
    }
    async getCharacterStatus(character, { level = 1, awakening = false, episode = CharacterEpisodeStatus.NONE, bloom = 0 }) {
        const level0 = await this.getCharacterLevel(level);
        const levelBonus = level0.characterStatusLevel / 100;
        const base = CharacterCalculator.getEpisodeBonus(episode);
        const bonus = (100 + await this.characterBloomService
            .getBloomBonusTotal(character.bloomBonusGroupMasterId, 'BaseCorrection', bloom) / 100 +
            (awakening ? 10 : 0)) / 100;
        return {
            preset: {
                level,
                awakening,
                episode,
                bloom
            },
            status: {
                vocal: CharacterCalculator.getStatus(character.minLevelStatus.vocal + base, levelBonus, bonus),
                expression: CharacterCalculator.getStatus(character.minLevelStatus.expression + base, levelBonus, bonus),
                concentration: CharacterCalculator
                    .getStatus(character.minLevelStatus.concentration + base, levelBonus, bonus)
            }
        };
    }
    async getMinCharacterStatus(character) {
        return await this.getCharacterStatus(character, {});
    }
    async getMaxCharacterStatus(character) {
        return await this.getCharacterStatus(character, {
            level: await this.getMaxCharacterLevel(), awakening: true, episode: CharacterEpisodeStatus.SECOND, bloom: 5
        });
    }
}
var CharacterEpisodeStatus;
(function (CharacterEpisodeStatus) {
    CharacterEpisodeStatus["NONE"] = "None";
    CharacterEpisodeStatus["FIRST"] = "First";
    CharacterEpisodeStatus["SECOND"] = "Second";
})(CharacterEpisodeStatus || (CharacterEpisodeStatus = {}));

class GachaService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getGachaes() {
        return await this.dataProvider.getMasterData('gacha');
    }
    async getCharacterFirstAppearGacha(characterId) {
        const gachaes = (await this.getGachaes()).filter(it => it.cardType === 'Character')
            .sort((a, b) => a.startDate - b.startDate);
        for (const gacha of gachaes) {
            if (gacha.things.find(it => it.thingId === characterId) !== undefined) {
                return gacha;
            }
        }
        return undefined;
    }
}

class StoryEventService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getStoryEvents() {
        return await this.dataProvider.getMasterData('storyEvent');
    }
    async getCharacterFirstAppearStoryEvent(displayStartAt) {
        const events = await this.getStoryEvents();
        return events.find(it => it.startDate <= displayStartAt && displayStartAt < it.forceEndDate);
    }
}

class CharacterService {
    dataProvider;
    characterBaseService;
    starActService;
    senseService;
    characterBloomService;
    storyEventService;
    gachaService;
    characterCalculator;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.characterBaseService = new CharacterBaseService(dataProvider);
        this.starActService = new StarActService(dataProvider);
        this.senseService = new SenseService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
        this.storyEventService = new StoryEventService(dataProvider);
        this.gachaService = new GachaService(dataProvider);
        this.characterCalculator = new CharacterCalculator(dataProvider);
    }
    async getCharacters() {
        return await this.dataProvider.getMasterData('character');
    }
    async getCharacter(id) {
        return await this.dataProvider.getMasterDataById('character', id);
    }
    async getCharacterDetail(id) {
        const character = await this.getCharacter(id);
        const event = await this.storyEventService.getCharacterFirstAppearStoryEvent(character.displayStartAt);
        const gacha = await this.gachaService.getCharacterFirstAppearGacha(character.id);
        return {
            id: character.id,
            name: character.name,
            rarity: character.rarity,
            attribute: character.attribute,
            status: [await this.characterCalculator.getMinCharacterStatus(character),
                await this.characterCalculator.getMaxCharacterStatus(character)],
            characterBase: await this.characterBaseService.getCharacterBaseName(character.characterBaseMasterId),
            characterBaseChinese: characterBaseChineseNames[character.id],
            starAct: await this.starActService.getStarActDetail(character.starActMasterId, character.bloomBonusGroupMasterId),
            sense: await this.senseService.getSenseDetail(character.senseMasterId, character.bloomBonusGroupMasterId),
            bloomBonuses: await this.characterBloomService.getBloomBonusDetails(character.bloomBonusGroupMasterId),
            displayStartAt: siriusTimestampToDate(character.displayStartAt),
            event: event === undefined ? '无' : event.title,
            gacha: gacha === undefined ? '无' : gacha.name
        };
    }
    async getAllCharacterDetails() {
        const characters = await this.getCharacters();
        return await Promise.all(characters.map(async (it) => await this.getCharacterDetail(it.id)));
    }
}

export { CachedDataProvider, CharacterService };

function findOrThrow(arr, p) {
    const result = arr.find(p);
    if (result === undefined)
        throw new Error('object not found');
    return result;
}
function getOrThrow(map, key) {
    const value = map.get(key);
    if (value === undefined)
        throw new Error('key not found');
    return value;
}

class GithubMasterProvider {
    async getMasterData(key) {
        const res = await fetch(`https://raw.githubusercontent.com/xfl03/sirius-master/main/${key}.json`);
        const json = await res.json();
        return json;
    }
    async getMasterDataById(key, id) {
        return findOrThrow(await this.getMasterData(key), it => it.id === id);
    }
}

class CachedDataProvider {
    dataProvider;
    constructor(dataProvider) {
        this.dataProvider = dataProvider;
    }
    static globalCache = new Map();
    static runningPromise = new Map();
    async getData(cache, cacheKey, promise) {
        if (cache.has(cacheKey))
            return cache.get(cacheKey);
        while (CachedDataProvider.runningPromise.has(cacheKey)) {
            await CachedDataProvider.runningPromise.get(cacheKey);
        }
        if (cache.has(cacheKey))
            return cache.get(cacheKey);
        CachedDataProvider.runningPromise.set(cacheKey, promise());
        const data = await getOrThrow(CachedDataProvider.runningPromise, cacheKey).then(data => {
            cache.set(cacheKey, data);
            return data;
        });
        CachedDataProvider.runningPromise.delete(cacheKey);
        return data;
    }
    async getMasterData(key) {
        return await this.getData(CachedDataProvider.globalCache, key, async () => await this.dataProvider.getMasterData(key));
    }
    static idMapCache = new Map();
    async getMasterDataById(key, id) {
        if (!CachedDataProvider.idMapCache.has(key)) {
            const map = new Map();
            const arr = await this.getMasterData(key);
            arr.forEach(it => map.set(it.id, it));
            CachedDataProvider.idMapCache.set(key, map);
        }
        return getOrThrow(getOrThrow(CachedDataProvider.idMapCache, key), id);
    }
}

class DataProviderFactory {
    static defaultDataProvider() {
        return new CachedDataProvider(new GithubMasterProvider());
    }
}

class CharacterBaseService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getCharacterBase(id) {
        return await this.dataProvider.getMasterDataById('characterBase', id);
    }
    async getCharacterBaseName(id) {
        const characterBase = await this.getCharacterBase(id);
        return characterBase.name;
    }
}

function toFixedString(num, fractionDigits = 1) {
    return num.toFixed(fractionDigits).replace(/\.0+$/, '');
}
function toRangeString(from, to) {
    return from === to ? toFixedString(from) : `${toFixedString(from)}~${toFixedString(to)}`;
}

class EffectService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getEffect(id) {
        return await this.dataProvider.getMasterDataById('effect', id);
    }
    async getEffects(ids) {
        return await Promise.all(ids.map(async (it) => await this.getEffect(it)));
    }
    getEffectDetail(effect, level) {
        const div = ['PercentageAddition', 'Multiplication'].includes(effect.calculationType) ? 100 : 1;
        const detail = findOrThrow(effect.details, it => it.level === level);
        return detail.value / div;
    }
    async getEffectRange(id, from = 1, to = 114514) {
        const effect = await this.getEffect(id);
        to = Math.min(effect.details.length, to);
        const f = this.getEffectDetail(effect, from);
        const t = this.getEffectDetail(effect, to);
        return toRangeString(f, t);
    }
    async getEffectDurationSecond(id) {
        const effect = await this.getEffect(id);
        return effect.durationSecond;
    }
}

class CharacterBloomService {
    dataProvider;
    effectService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
    }
    async getCharacterBloomBonusGroup(id) {
        return await this.dataProvider.getMasterDataById('characterBloomBonusGroup', id);
    }
    async getBloomBonusTotal(id, type, bloom = 5) {
        const bonus = await this.getCharacterBloomBonusGroup(id);
        const effects = await this.effectService
            .getEffects(bonus.bloomBonuses.filter(it => it.phase <= bloom)
            .map(it => it.effectMasterId));
        return effects
            .filter(it => it.type === type)
            .map(it => it.details[0].value)
            .reduce((sum, it) => sum + it, 0);
    }
    async getBloomBonusDetails(id) {
        const bonuses = await this.getCharacterBloomBonusGroup(id);
        return Array.from(new Set(bonuses.bloomBonuses.map(it => it.phase)))
            .sort((a, b) => a - b).map(phase => {
            return {
                phase,
                descriptions: bonuses.bloomBonuses
                    .filter(it => it.phase === phase)
                    .map(it => it.description)
            };
        });
    }
}

class SenseService {
    dataProvider;
    effectService;
    characterBloomService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
    }
    async getSense(id) {
        return await this.dataProvider.getMasterDataById('sense', id);
    }
    async getSenseDetail(id, bloomBonusGroupId) {
        const sense = await this.getSense(id);
        let description = sense.description;
        for (let i = 0; i < sense.preEffects.length; ++i) {
            const effect = sense.preEffects[i];
            description = description.replaceAll(`[:pre${i + 1}]`, await this.effectService.getEffectRange(effect.effectMasterId, 1, 5));
        }
        for (let i = 0; i < sense.branches.length; ++i) {
            const branch = sense.branches[i];
            for (let j = 0; j < branch.branchEffects.length; ++j) {
                const effect = branch.branchEffects[i];
                description = description.replaceAll(`[:param${i + 1}${j + 1}]`, await this.effectService.getEffectRange(effect.effectMasterId, 1, 5));
                const durationSecond = await this.effectService.getEffectDurationSecond(effect.effectMasterId);
                if (durationSecond > 0) {
                    description = description.replaceAll('[:sec]', durationSecond.toString());
                }
            }
        }
        const gauge = sense.acquirableGauge;
        if (gauge > 0) {
            description = description.replaceAll('[:gauge]', gauge.toString());
        }
        const base = sense.acquirableScorePercent / 100;
        const level = sense.scoreUpPerLevel / 100;
        if (base > 0 || level > 0) {
            description = description.replaceAll('[:score]', toRangeString(base, base + level * 5));
        }
        return {
            descriptions: description.split('Ôºè'),
            type: sense.type,
            lightCount: sense.lightCount,
            coolTime: {
                origin: sense.coolTime,
                bloom: sense.coolTime - await this.characterBloomService
                    .getBloomBonusTotal(bloomBonusGroupId, 'SenseRecastDown')
            }
        };
    }
}

class StarActService {
    dataProvider;
    effectService;
    characterBloomService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
    }
    async getStarAct(id) {
        return await this.dataProvider.getMasterDataById('starAct', id);
    }
    async getStarActCondition(id) {
        return await this.dataProvider.getMasterDataById('starActCondition', id);
    }
    async getStarActDetail(id, bloomBonusGroupId) {
        const starAct = await this.getStarAct(id);
        const base = starAct.acquirableScorePercent / 100;
        const level = starAct.scoreUpPerLevel / 100;
        const description = starAct.description.replaceAll('[:score]', toRangeString(base, base + level * 5));
        const condition = await this.getStarActCondition(starAct.starActConditionMasterId);
        return {
            description,
            condition: {
                origin: {
                    freeLight: condition.freeLight,
                    supportLight: condition.supportLight,
                    controlLight: condition.controlLight,
                    amplificationLight: condition.amplificationLight,
                    specialLight: condition.specialLight
                },
                bloom: {
                    freeLight: condition.freeLight,
                    supportLight: condition.supportLight - await this.characterBloomService
                        .getBloomBonusTotal(bloomBonusGroupId, 'DecreaseRequireSupportLight'),
                    controlLight: condition.controlLight - await this.characterBloomService
                        .getBloomBonusTotal(bloomBonusGroupId, 'DecreaseRequireControlLight'),
                    amplificationLight: condition.amplificationLight - await this.characterBloomService
                        .getBloomBonusTotal(bloomBonusGroupId, 'DecreaseRequireAmplificationLight'),
                    specialLight: condition.specialLight - await this.characterBloomService
                        .getBloomBonusTotal(bloomBonusGroupId, 'DecreaseRequireSpecialLight')
                }
            }
        };
    }
}

function siriusTimestampToDate(timestamp) {
    return new Date(timestamp * 1000 - 9 * 3600 * 1000);
}

class CharacterCalculator {
    dataProvider;
    characterBloomService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.characterBloomService = new CharacterBloomService(dataProvider);
    }
    async getCharacterLevel(level) {
        const levels = await this.dataProvider.getMasterData('characterLevel');
        return findOrThrow(levels, it => it.level === level);
    }
    async getMaxCharacterLevel() {
        const levels = await this.dataProvider.getMasterData('characterLevel');
        return levels.filter(it => siriusTimestampToDate(it.startDate).getTime() <= Date.now())
            .reduce((max, it) => Math.max(max, it.level), 0);
    }
    static getEpisodeBonus(episode) {
        switch (episode) {
            case CharacterEpisodeStatus.NONE:
                return 0;
            case CharacterEpisodeStatus.FIRST:
                return 2;
            case CharacterEpisodeStatus.SECOND:
                return 5;
        }
    }
    static getStatus(base, levelBonus, bonus) {
        return Math.floor(base * levelBonus * bonus);
    }
    async getCharacterStatus(character, { level = 1, awakening = false, episode = CharacterEpisodeStatus.NONE, bloom = 0 }) {
        const level0 = await this.getCharacterLevel(level);
        const levelBonus = level0.characterStatusLevel / 100;
        const base = CharacterCalculator.getEpisodeBonus(episode);
        const bonus = (100 + await this.characterBloomService
            .getBloomBonusTotal(character.bloomBonusGroupMasterId, 'BaseCorrection', bloom) / 100 +
            (awakening ? 10 : 0)) / 100;
        return {
            preset: {
                level,
                awakening,
                episode,
                bloom
            },
            status: {
                vocal: CharacterCalculator.getStatus(character.minLevelStatus.vocal + base, levelBonus, bonus),
                expression: CharacterCalculator.getStatus(character.minLevelStatus.expression + base, levelBonus, bonus),
                concentration: CharacterCalculator
                    .getStatus(character.minLevelStatus.concentration + base, levelBonus, bonus)
            }
        };
    }
    async getMinCharacterStatus(character) {
        return await this.getCharacterStatus(character, {});
    }
    async getMaxCharacterStatus(character) {
        return await this.getCharacterStatus(character, {
            level: await this.getMaxCharacterLevel(), awakening: true, episode: CharacterEpisodeStatus.SECOND, bloom: 5
        });
    }
}
var CharacterEpisodeStatus;
(function (CharacterEpisodeStatus) {
    CharacterEpisodeStatus["NONE"] = "None";
    CharacterEpisodeStatus["FIRST"] = "First";
    CharacterEpisodeStatus["SECOND"] = "Second";
})(CharacterEpisodeStatus || (CharacterEpisodeStatus = {}));

class GachaService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getGachaes() {
        return await this.dataProvider.getMasterData('gacha');
    }
    async getCharacterFirstAppearGacha(characterId) {
        const gachaes = (await this.getGachaes()).filter(it => it.cardType === 'Character')
            .sort((a, b) => a.startDate - b.startDate);
        for (const gacha of gachaes) {
            if (gacha.things.find(it => it.thingId === characterId) !== undefined) {
                return gacha;
            }
        }
        return undefined;
    }
}

class StoryEventService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getStoryEvents() {
        return await this.dataProvider.getMasterData('storyEvent');
    }
    async getCharacterFirstAppearStoryEvent(displayStartAt) {
        const events = await this.getStoryEvents();
        return events.find(it => it.startDate <= displayStartAt && displayStartAt < it.forceEndDate);
    }
}

class CharacterService {
    dataProvider;
    characterBaseService;
    starActService;
    senseService;
    characterBloomService;
    storyEventService;
    gachaService;
    characterCalculator;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.characterBaseService = new CharacterBaseService(dataProvider);
        this.starActService = new StarActService(dataProvider);
        this.senseService = new SenseService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
        this.storyEventService = new StoryEventService(dataProvider);
        this.gachaService = new GachaService(dataProvider);
        this.characterCalculator = new CharacterCalculator(dataProvider);
    }
    async getCharacter(id) {
        return await this.dataProvider.getMasterDataById('character', id);
    }
    async getCharacterDetail(id) {
        const character = await this.getCharacter(id);
        const event = await this.storyEventService.getCharacterFirstAppearStoryEvent(character.displayStartAt);
        const gacha = await this.gachaService.getCharacterFirstAppearGacha(character.id);
        return {
            name: character.name,
            rarity: character.rarity,
            attribute: character.attribute,
            status: [await this.characterCalculator.getMinCharacterStatus(character),
                await this.characterCalculator.getMaxCharacterStatus(character)],
            characterBase: await this.characterBaseService.getCharacterBaseName(character.characterBaseMasterId),
            starAct: await this.starActService.getStarActDetail(character.starActMasterId, character.bloomBonusGroupMasterId),
            sense: await this.senseService.getSenseDetail(character.senseMasterId, character.bloomBonusGroupMasterId),
            bloomBonuses: await this.characterBloomService.getBloomBonusDetails(character.bloomBonusGroupMasterId),
            displayStartAt: siriusTimestampToDate(character.displayStartAt),
            event: event === undefined ? 'Êó†' : event.title,
            gacha: gacha === undefined ? 'Êó†' : gacha.name
        };
    }
}

export { CachedDataProvider, CharacterService };

function findOrThrow(arr, p) {
    const result = arr.find(p);
    if (result === undefined)
        throw new Error('object not found');
    return result;
}
function getOrThrow(map, key) {
    const value = map.get(key);
    if (value === undefined)
        throw new Error('key not found');
    return value;
}
function getOrDefault(map, key, defaultValue) {
    const value = map.get(key);
    if (value === undefined)
        return defaultValue;
    return value;
}

class DataProvider {
    async getMasterDataById(key, id) {
        return findOrThrow(await this.getMasterData(key), it => it.id === id);
    }
}

class CachedDataProvider extends DataProvider {
    dataProvider;
    constructor(dataProvider) {
        super();
        this.dataProvider = dataProvider;
    }
    static globalCache = new Map();
    static runningPromise = new Map();
    async getData(cache, cacheKey, promise) {
        if (cache.has(cacheKey))
            return cache.get(cacheKey);
        while (CachedDataProvider.runningPromise.has(cacheKey)) {
            await CachedDataProvider.runningPromise.get(cacheKey);
        }
        if (cache.has(cacheKey))
            return cache.get(cacheKey);
        CachedDataProvider.runningPromise.set(cacheKey, promise());
        const data = await getOrThrow(CachedDataProvider.runningPromise, cacheKey).then(data => {
            cache.set(cacheKey, data);
            return data;
        });
        CachedDataProvider.runningPromise.delete(cacheKey);
        return data;
    }
    async getMasterData(key) {
        return await this.getData(CachedDataProvider.globalCache, key, async () => await this.dataProvider.getMasterData(key));
    }
    static idMapCache = new Map();
    async getMasterDataById(key, id) {
        if (!CachedDataProvider.idMapCache.has(key)) {
            const map = new Map();
            const arr = await this.getMasterData(key);
            arr.forEach(it => map.set(it.id, it));
            CachedDataProvider.idMapCache.set(key, map);
        }
        return getOrThrow(getOrThrow(CachedDataProvider.idMapCache, key), id);
    }
}

class UrlDataProvider extends DataProvider {
    async getMasterData(key) {
        const res = await fetch(this.getUrl(key));
        const json = await res.json();
        return json;
    }
}

class CloudFlareDataProvider extends UrlDataProvider {
    getUrl(key) {
        return `https://sirius.3-3.dev/master/${key}.json`;
    }
}

class DataProviderFactory {
    static defaultDataProvider() {
        return new CachedDataProvider(new CloudFlareDataProvider());
    }
}

class CharacterBaseService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getCharacterBase(id) {
        return await this.dataProvider.getMasterDataById('characterBase', id);
    }
    async getCharacterBaseName(id) {
        const characterBase = await this.getCharacterBase(id);
        return characterBase.name;
    }
}

function toFixedString(num, fractionDigits = 1) {
    return num.toFixed(fractionDigits).replace(/\.0+$/, '');
}
function toRangeString(from, to) {
    return from === to ? toFixedString(from) : `${toFixedString(from)}~${toFixedString(to)}`;
}

class EffectService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getEffect(id) {
        return await this.dataProvider.getMasterDataById('effect', id);
    }
    async getEffects(ids) {
        return await Promise.all(ids.map(async (it) => await this.getEffect(it)));
    }
    getEffectDetail(effect, level) {
        const div = ['PercentageAddition', 'Multiplication'].includes(effect.calculationType) ? 100 : 1;
        const detail = findOrThrow(effect.details, it => it.level === level);
        return detail.value / div;
    }
    async getEffectDetails(id, maxLevel) {
        const effect = await this.getEffect(id);
        return Array(maxLevel).fill(0).map((_, i) => i + 1)
            .map(it => this.getEffectDetail(effect, it));
    }
    async getEffectRange(id, from = 1, to = 114514) {
        const effect = await this.getEffect(id);
        to = Math.min(effect.details.length, to);
        const f = this.getEffectDetail(effect, from);
        const t = this.getEffectDetail(effect, to);
        return toRangeString(f, t);
    }
    async getEffectDurationSecond(id) {
        const effect = await this.getEffect(id);
        return effect.durationSecond;
    }
    async getEffectType(id) {
        const effect = await this.getEffect(id);
        return effect.type;
    }
}

const characterEffectTranslations = [{
        japanese: '[:gauge]のプリンシパルゲージを獲得',
        chinese: '获得[:gauge]点Principal Gauge'
    }, {
        japanese: '[:score]倍のスコアを獲得',
        chinese: '获得自身演技力[:score]倍的分数'
    }, {
        japanese: '[:sec]秒間、[COMPANY]のアクターにスターアクトスコア[:param11]％UP効果',
        chinese: '[:sec]秒内，[COMPANY]的演员Star Act中获得的分数提升[:param11]%'
    }, {
        japanese: '[:sec]秒間、[COMPANY]のアクターにセンススコア[:param11]％UP効果',
        chinese: '[:sec]秒内，[COMPANY]的演员Sense中获得的分数提升[:param11]%'
    }, {
        japanese: '[COMPANY]のアクターのCTを[TIME]秒短縮',
        chinese: '[COMPANY]的演员CT缩短[TIME]秒'
    }, {
        japanese: '[CHARACTER]のCTを[TIME]秒短縮',
        chinese: '[CHARACTER]的CT缩短[TIME]秒'
    }, {
        japanese: 'ここな編成時、ここなが代わりにセンスを発動し、ここなのスコア獲得量[:pre1]％UP',
        chinese: '队伍中有凤心菜编成时，凤心菜代替发动Sense，同时使凤心菜的分数获得量提高[:pre1]%'
    }, {
        japanese: 'ここな編成時、ここなが代わりにセンスを発動し、ここなのスコア獲得量[:pre2]％、スターアクトスコア獲得量[:pre3]％UP',
        chinese: '队伍中有凤心菜编成时，凤心菜代替发动Sense，同时使凤心菜的分数获得量提高[:pre2]%，Star Act分数获得量提升[:pre3]%'
    }, {
        japanese: 'センス発動後、追加で[:param11]のプリンシパルゲージを獲得',
        chinese: 'Sense发动后，追加获得[:param11]点Principal Gauge'
    }, {
        japanese: 'ライフが多いほど[CHARACTER]のスコア獲得量UP（最大＋100％）',
        chinese: '血量越多，[CHARACTER]的分数获得量越高（最大+100％）'
    }, {
        japanese: 'ライフが少ないほど[CHARACTER]のスコア獲得量UP（最大+100％）',
        chinese: '血量越少，[CHARACTER]的分数获得量越高（最大+100％）'
    }, {
        japanese: 'ライフを[:param11]回復',
        chinese: '回复[:param11]点血量'
    }, {
        japanese: '効果無し（所持している「光」は維持される）',
        chinese: '无效果（维持目前所拥有的光）'
    }, {
        japanese: '総演技力の[:score]倍のスコアを獲得',
        chinese: '获得总演技力[:score]倍的分数'
    }];
const effectTimes = [1, 2, 3, 5, 8, 9, 10];

const characterBaseChineseNames = {
    101: '凤心菜',
    102: '静香',
    103: '卡特莉娜·格利贝尔',
    104: '新妻八惠',
    105: '柳场潘达',
    106: '流石知冴',
    201: '连尺野初魅',
    202: '乌森大黑',
    203: '舍人仁花子',
    204: '万容',
    205: '笔岛时雨',
    301: '千寿历',
    302: '拉莫娜·沃尔芙',
    303: '王雪',
    304: '莉莉亚·库尔特贝',
    305: '与那国绯花里',
    401: '千寿伊吕波',
    402: '白丸美兔',
    403: '阿岐留卡米拉',
    404: '猫足蕾',
    405: '本巢叶羽'
};
const characterBaseTranslations = [{
        japanese: 'ここな',
        chinese: '凤心菜'
    }, {
        japanese: '静香',
        chinese: '静香'
    }, {
        japanese: 'カトリナ・グリーベル',
        chinese: '卡特莉娜·格利贝尔'
    }, {
        japanese: '八恵',
        chinese: '新妻八惠'
    }, {
        japanese: 'ぱんだ',
        chinese: '柳场潘达'
    }, {
        japanese: '知冴',
        chinese: '流石知冴'
    }, {
        japanese: '初魅',
        chinese: '连尺野初魅'
    }, {
        japanese: '大黒',
        chinese: '乌森大黑'
    }, {
        japanese: '仁花子',
        chinese: '舍人仁花子'
    }, {
        japanese: '萬容',
        chinese: '万容'
    }, {
        japanese: 'しぐれ',
        chinese: '笔岛时雨'
    }, {
        japanese: '暦',
        chinese: '千寿历'
    }, {
        japanese: 'ラモーナ・ウォルフ',
        chinese: '拉莫娜·沃尔芙'
    }, {
        japanese: '王雪',
        chinese: '王雪'
    }, {
        japanese: 'リリヤ・クルトベイ',
        chinese: '莉莉亚·库尔特贝'
    }, {
        japanese: '緋花里',
        chinese: '与那国绯花里'
    }, {
        japanese: 'いろは',
        chinese: '千寿伊吕波'
    }, {
        japanese: '美兎',
        chinese: '白丸美兔'
    }, {
        japanese: 'カミラ',
        chinese: '阿岐留卡米拉'
    }, {
        japanese: '蕾',
        chinese: '猫足蕾'
    }, {
        japanese: '叶羽',
        chinese: '本巢叶羽'
    }];
const characterStatusTranslations = [{
        japanese: '歌唱力',
        chinese: '歌唱力'
    }, {
        japanese: '表現力',
        chinese: '表现力'
    }, {
        japanese: '集中力',
        chinese: '集中力'
    }, {
        japanese: '演技力',
        chinese: '演技力'
    }];
const characterAttributeTranslations = [{
        japanese: '<color=#ff679d>憐属性</color>',
        chinese: '<color=#ff679d>怜属性</color>'
    }, {
        japanese: '<color=#33B4DF>凛属性</color>',
        chinese: '<color=#33B4DF>凛属性</color>'
    }, {
        japanese: '<color=#7AC940>彩属性</color>',
        chinese: '<color=#7AC940>彩属性</color>'
    }, {
        japanese: '<color=#FF9314>陽属性</color>',
        chinese: '<color=#FF9314>阳属性</color>'
    }];

const companyTranslations = [{
        japanese: 'シリウス',
        chinese: '天狼星'
    }, {
        japanese: 'Eden',
        chinese: 'Eden'
    }, {
        japanese: '銀河座',
        chinese: '银河座'
    }, {
        japanese: '劇団電姫',
        chinese: '剧团电姬'
    }];

const bloomTranslations = [{
        japanese: 'スターアクト発動に必要な[LIGHT]の光の個数が1個減少',
        chinese: 'Star Act发动所需要的[LIGHT]光个数减1'
    }, {
        japanese: 'センスのCTが[TIME]秒減少',
        chinese: 'Sense的CT缩短[TIME]秒'
    }, {
        japanese: '公演での報酬量が10％上昇',
        chinese: '公演的报酬量上升10%'
    }, {
        japanese: '初期プリンシパルゲージが[PG]上昇',
        chinese: '初始Principal Gauge上升[PG]'
    }, {
        japanese: '初期ライフが[LIFE]上昇',
        chinese: '初始血量上升[LIFE]'
    }, {
        japanese: '基礎スコアが[SCORE]％上昇',
        chinese: '基础分数提升[SCORE]%'
    }, {
        japanese: '演技力[STATUS]％UP',
        chinese: '演技力上升[STATUS]%'
    }];
const bloomPrincipalGaugeBonuses = [20, 30, 50];
const bloomLifeBonuses = [40, 60, 100];
const bloomScoreBonuses = [1, 2, 3, 5, 10];
const bloomStatusBonuses = [2, 3, 4, 6, 8, 12, 16, 18, 24];

const lightTranslations = [{
        japanese: '支援',
        chinese: '支援系'
    }, {
        japanese: '支配',
        chinese: '支配系'
    }, {
        japanese: '増幅',
        chinese: '增幅系'
    }, {
        japanese: '特殊',
        chinese: '特殊系'
    }];
const lightAdditionTranslations = [{
        japanese: '支援系の光「<color=#228b22>*</color>」',
        chinese: '支援系的光「<color=#228b22>✦</color>」'
    }, {
        japanese: '支配系の光「<color=#ff0000>*</color>」',
        chinese: '支配系的光「<color=#ff0000>✦</color>」'
    }, {
        japanese: '増幅系の光「<color=#ffd700>*</color>」',
        chinese: '增幅系的光「<color=#ffd700>✦</color>」'
    }, {
        japanese: '特殊系の光「<color=#0000ff>*</color>」',
        chinese: '特殊系的光「<color=#0000ff>✦</color>」'
    }, {
        japanese: 'SP光',
        chinese: 'SP光'
    }];

const posterEffectTranslations = [{
        japanese: '全アクターの演技力が[:param11]%上昇',
        chinese: '所有演员的演技力提升[:param11]%'
    }, {
        japanese: '全アクターの演技力が[:param11]％上昇',
        chinese: '所有演员的演技力提升[:param11]%'
    }, {
        japanese: '[COMPANY]に所属するアクターの演技力が[:param11]%上昇',
        chinese: '[COMPANY]的演员的演技力提升[:param11]%'
    }, {
        japanese: '[COMPANY]に所属するアクターの演技力が[:param11]％上昇',
        chinese: '[COMPANY]的演员的演技力提升[:param11]%'
    }, {
        japanese: '[ATTRIBUTE]のアクターの演技力が[:param11]%上昇',
        chinese: '[ATTRIBUTE]演员的演技力提升[:param11]%'
    }, {
        japanese: '[COMPANY]に所属しているアクターのみで編成している場合、追加で全アクターの[CHARACTER_STATUS]が[:param11]％上昇',
        chinese: '在仅有[COMPANY]的演员编成的情况下，所有演员的[CHARACTER_STATUS]追加提升[:param11]%'
    }, {
        japanese: '公演開始時、P.ゲージが[:param11]上昇',
        chinese: '公演开始时，获得[:param11]点Principle Gauge'
    }, {
        japanese: '自身の[CHARACTER_STATUS]が[:param11]%上昇',
        chinese: '自身的[CHARACTER_STATUS]提升[:param11]%'
    }, {
        japanese: '自身の[CHARACTER_STATUS]が[:param11]％上昇',
        chinese: '自身的[CHARACTER_STATUS]提升[:param11]%'
    }, {
        japanese: 'センス発動直後、自身の[CHARACTER_STATUS]の[:param11]倍のスコアを獲得',
        chinese: 'Sense发动后，获得自身[CHARACTER_STATUS][:param11]倍的分数'
    }, {
        japanese: '公演開始時、ライフが[:param11]上昇',
        chinese: '公演开始时，提升[:param11]点血量'
    }, {
        japanese: 'センス発動直後、ライフを[:param11]回復',
        chinese: 'Sense发动之后，回复[:param11]点血量'
    }, {
        japanese: 'センス発動直後、現在のスコアの[:param11]%のスコアを獲得',
        chinese: 'Sense发动之后，获得现在分数的[:param11]%的分数'
    }, {
        japanese: 'センスで付与する「光」の付与数が[:param11]個増加',
        chinese: 'Sense所给予的「光」给予数量增加[:param11]个'
    }, {
        japanese: '自身のセンスのCTが[:param11]秒短縮',
        chinese: '自身Sense的CT缩短[:param11]秒'
    }, {
        japanese: '自身のセンスのCTを[:param11]秒短縮',
        chinese: '自身Sense的CT缩短[:param11]秒'
    }, {
        japanese: 'センスによるP.ゲージの獲得量が[:param11]%UP',
        chinese: 'Sense中的Principle Gauge获得量提升[:param11]%'
    }, {
        japanese: '公演開始時、ライフが2000上昇',
        chinese: '公演开始时，提升2000点血量'
    }, {
        japanese: '公演開始時、ライフを999減少',
        chinese: '公演开始时，减少999点血量'
    }, {
        japanese: '公演開始時、ライフガード（10回）を付与',
        chinese: '公演开始时，给予10次血量保护'
    }, {
        japanese: 'プリンシパルゲージの上限を1000上昇',
        chinese: 'Principle Gauge的上限提升1000'
    }, {
        japanese: 'センスを発動しなくなるが、自身の演技力が2倍',
        chinese: '演员的Sense无法发动，自身演技力翻倍'
    }, {
        japanese: '編成されている属性数が少ないほど自身の[CHARACTER_STATUS]が上昇（1属性：[:param11]%／2属性：[:param21]%／3属性：[:param31]%／4属性：[:param41]%）',
        chinese: '队伍中编成的属性数越少，自身的[CHARACTER_STATUS]上升越高（1属性：[:param11]%/2属性：[:param21]%/3属性：[:param31]%/4属性：[:param41]%）'
    }, {
        japanese: '公演開始時、[LIGHT_ADDITION]を[:param11]個付与（効果は公演開始時1回のみ発動する）',
        chinese: '公演开始时，给予[:param11]个[LIGHT_ADDITION]（效果只在公演开始时发动1次）'
    }, {
        japanese: '公演開始時、[LIGHT_ADDITION]を[:param11]付与（効果は公演開始時1回のみ発動する）',
        chinese: '公演开始时，给予[:param11]个[LIGHT_ADDITION]（效果只在公演开始时发动1次）'
    }, {
        japanese: '公演と協力公演の公演報酬が[:param11]%増加（アクセサリーを除く）',
        chinese: '公演和协力公演的公演报酬提升[:param11]%（饰品除外）'
    }, {
        japanese: '公演と協力公演の公演報酬が[:param11]％増加（アクセサリーを除く）',
        chinese: '公演和协力公演的公演报酬提升[:param11]%（饰品除外）'
    }];
const posterEffectRequirementTranslations = [{
        japanese: '[COMPANY]に所属するアクターが装備',
        chinese: '由[COMPANY]的演员装备'
    }, {
        japanese: '[CHARACTER]が装備',
        chinese: '由[CHARACTER]装备'
    }, {
        japanese: '[ATTRIBUTE]のアクターが装備',
        chinese: '由[ATTRIBUTE]的演员装备'
    }];

class TranslationService {
    static translationService = new TranslationService();
    chineseTranslationMap = new Map();
    constructor() {
        this.buildChineseTranslationMap();
    }
    static getInstance() {
        return TranslationService.translationService;
    }
    addChineseTranslation(translation) {
        this.chineseTranslationMap.set(translation.japanese, translation.chinese);
    }
    dfsAddChineseTranslation(translation, replacements) {
        for (const key of replacements.keys()) {
            if (translation.japanese.includes(key)) {
                getOrThrow(replacements, key).forEach(replacement => {
                    const newTranslation = {
                        japanese: translation.japanese.replaceAll(key, replacement.japanese),
                        chinese: translation.chinese.replaceAll(key, replacement.chinese)
                    };
                    this.dfsAddChineseTranslation(newTranslation, replacements);
                });
                return;
            }
        }
        this.chineseTranslationMap.set(translation.japanese, translation.chinese);
    }
    static addReplacements(replacements, key, numbers) {
        replacements.set(key, numbers.map(it => { return { japanese: it.toString(), chinese: it.toString() }; }));
    }
    addTranslations(translations, replacements) {
        translations.forEach(it => { this.dfsAddChineseTranslation(it, replacements); });
    }
    buildChineseTranslationMap() {
        if (this.chineseTranslationMap.size > 0) {
            return;
        }
        characterBaseTranslations.forEach(it => { this.addChineseTranslation(it); });
        companyTranslations.forEach(it => { this.addChineseTranslation(it); });
        const replacements = new Map();
        TranslationService.addReplacements(replacements, '[TIME]', effectTimes);
        TranslationService.addReplacements(replacements, '[PG]', bloomPrincipalGaugeBonuses);
        TranslationService.addReplacements(replacements, '[LIFE]', bloomLifeBonuses);
        TranslationService.addReplacements(replacements, '[SCORE]', bloomScoreBonuses);
        TranslationService.addReplacements(replacements, '[STATUS]', bloomStatusBonuses);
        replacements.set('[CHARACTER]', characterBaseTranslations);
        replacements.set('[COMPANY]', companyTranslations);
        replacements.set('[LIGHT]', lightTranslations);
        replacements.set('[ATTRIBUTE]', characterAttributeTranslations);
        replacements.set('[CHARACTER_STATUS]', characterStatusTranslations);
        replacements.set('[LIGHT_ADDITION]', lightAdditionTranslations);
        this.addTranslations(characterEffectTranslations, replacements);
        this.addTranslations(bloomTranslations, replacements);
        this.addTranslations(posterEffectTranslations, replacements);
        this.addTranslations(posterEffectRequirementTranslations, replacements);
    }
    getChineseTranslation(japanese) {
        return getOrDefault(this.chineseTranslationMap, japanese.trim(), japanese);
    }
    getAllTranslations() {
        return new Map(this.chineseTranslationMap);
    }
}

class CharacterBloomService {
    dataProvider;
    effectService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
    }
    async getCharacterBloomBonusGroup(id) {
        return await this.dataProvider.getMasterDataById('characterBloomBonusGroup', id);
    }
    async getBloomBonusTotal(id, type, bloom = 5) {
        const bonus = await this.getCharacterBloomBonusGroup(id);
        const effects = await this.effectService
            .getEffects(bonus.bloomBonuses.filter(it => it.phase <= bloom)
            .map(it => it.effectMasterId));
        return effects
            .filter(it => it.type === type)
            .map(it => it.details[0].value)
            .reduce((sum, it) => sum + it, 0);
    }
    async getBloomBonusDetails(id) {
        const bonuses = await this.getCharacterBloomBonusGroup(id);
        return Array.from(new Set(bonuses.bloomBonuses.map(it => it.phase)))
            .sort((a, b) => a - b).map(phase => {
            const descriptions = bonuses.bloomBonuses
                .filter(it => it.phase === phase)
                .map(it => it.description);
            return {
                phase,
                descriptions,
                descriptionsChinese: descriptions
                    .map(it => TranslationService.getInstance().getChineseTranslation(it))
            };
        });
    }
}

class SenseService {
    dataProvider;
    effectService;
    characterBloomService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
    }
    async getSense(id) {
        return await this.dataProvider.getMasterDataById('sense', id);
    }
    async getSenseDescription(sense, description) {
        for (let i = 0; i < sense.preEffects.length; ++i) {
            const effect = sense.preEffects[i];
            description = description.replaceAll(`[:pre${i + 1}]`, await this.effectService.getEffectRange(effect.effectMasterId, 1, 5));
        }
        for (let i = 0; i < sense.branches.length; ++i) {
            const branch = sense.branches[i];
            for (let j = 0; j < branch.branchEffects.length; ++j) {
                const effect = branch.branchEffects[j];
                description = description.replaceAll(`[:param${i + 1}${j + 1}]`, await this.effectService.getEffectRange(effect.effectMasterId, 1, 5));
                const durationSecond = await this.effectService.getEffectDurationSecond(effect.effectMasterId);
                if (durationSecond > 0) {
                    description = description.replaceAll('[:sec]', durationSecond.toString());
                }
            }
        }
        const gauge = sense.acquirableGauge;
        if (gauge > 0) {
            description = description.replaceAll('[:gauge]', gauge.toString());
        }
        const base = sense.acquirableScorePercent / 100;
        const level = sense.scoreUpPerLevel / 100;
        if (base > 0 || level > 0) {
            description = description.replaceAll('[:score]', toRangeString(base, base + level * 4));
        }
        return description;
    }
    async getSenseEffectTypes(sense) {
        const set = new Set();
        const preEffects = sense.preEffects.map(it => it.effectMasterId);
        for (const id of preEffects) {
            set.add(await this.effectService.getEffectType(id));
        }
        const branchEffects = sense.branches.flatMap(it => it.branchEffects)
            .map(it => it.effectMasterId);
        for (const id of branchEffects) {
            set.add(await this.effectService.getEffectType(id));
        }
        return Array.from(set);
    }
    async getSenseDetail(id, bloomBonusGroupId) {
        const sense = await this.getSense(id);
        const descriptions = await Promise.all(sense.description.split('／')
            .map(async (it) => await this.getSenseDescription(sense, it)));
        const descriptionsChinese = await Promise.all(sense.description.split('／')
            .map(it => TranslationService.getInstance().getChineseTranslation(it))
            .map(async (it) => await this.getSenseDescription(sense, it)));
        return {
            descriptions,
            descriptionsChinese,
            type: sense.type,
            lightCount: sense.lightCount,
            acquirableGauge: sense.acquirableGauge,
            coolTime: {
                origin: sense.coolTime,
                bloom: sense.coolTime - await this.characterBloomService
                    .getBloomBonusTotal(bloomBonusGroupId, 'SenseRecastDown')
            },
            effectTypes: await this.getSenseEffectTypes(sense)
        };
    }
}

const lights = [
    {
        type: 'Alternative',
        typeChinese: '任意系',
        typeChineseShort: '任意',
        condition: 'freeLight',
        decrease: 'DecreaseRequireAlternativeLight'
    },
    {
        type: 'Support',
        typeChinese: '支援系',
        typeChineseShort: '绿',
        condition: 'supportLight',
        decrease: 'DecreaseRequireSupportLight'
    },
    {
        type: 'Control',
        typeChinese: '支配系',
        typeChineseShort: '红',
        condition: 'controlLight',
        decrease: 'DecreaseRequireControlLight'
    },
    {
        type: 'Amplification',
        typeChinese: '增幅系',
        typeChineseShort: '黄',
        condition: 'amplificationLight',
        decrease: 'DecreaseRequireAmplificationLight'
    },
    {
        type: 'Special',
        typeChinese: '特殊系',
        typeChineseShort: '蓝',
        condition: 'specialLight',
        decrease: 'DecreaseRequireSpecialLight'
    }
];

class StarActService {
    dataProvider;
    effectService;
    characterBloomService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
    }
    async getStarAct(id) {
        return await this.dataProvider.getMasterDataById('starAct', id);
    }
    async getStarActCondition(id) {
        return await this.dataProvider.getMasterDataById('starActCondition', id);
    }
    async getStarActDetail(id, bloomBonusGroupId) {
        const starAct = await this.getStarAct(id);
        const base = starAct.acquirableScorePercent / 100;
        const level = starAct.scoreUpPerLevel / 100;
        const scoreRange = toRangeString(base, base + level * 5);
        const description = starAct.description
            .replaceAll('[:score]', scoreRange);
        const descriptionChinese = TranslationService.getInstance().getChineseTranslation(starAct.description)
            .replaceAll('[:score]', scoreRange);
        const condition = await this.getStarActCondition(starAct.starActConditionMasterId);
        const conditions = await Promise.all([condition.freeLight, condition.supportLight, condition.controlLight,
            condition.amplificationLight, condition.specialLight].map(async (it, i) => {
            const { type, typeChinese, decrease } = lights[i];
            return {
                type,
                typeChinese,
                origin: it,
                bloom: it - await this.characterBloomService.getBloomBonusTotal(bloomBonusGroupId, decrease)
            };
        }));
        return {
            description,
            descriptionChinese,
            conditions
        };
    }
}

function siriusTimestampToDate(timestamp) {
    return new Date(timestamp * 1000 - 9 * 3600 * 1000);
}

class CharacterEpisodeService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getCharacterEpisodes() {
        return await this.dataProvider.getMasterData('characterEpisode');
    }
    async getCharacterEpisodeDetails(characterId) {
        const episodes = await this.getCharacterEpisodes();
        return episodes.filter(it => it.characterMasterId === characterId).map(it => {
            return {
                id: it.id,
                episodeOrder: it.episodeOrder
            };
        });
    }
    async getCharacterMaxEpisodeStatus(characterId) {
        const episodes = (await this.getCharacterEpisodes())
            .filter(it => it.characterMasterId === characterId)
            .map(it => it.episodeOrder);
        if (episodes.includes('Second')) {
            return CharacterEpisodeStatus.SECOND;
        }
        if (episodes.includes('First')) {
            return CharacterEpisodeStatus.FIRST;
        }
        return CharacterEpisodeStatus.NONE;
    }
}
var CharacterEpisodeStatus;
(function (CharacterEpisodeStatus) {
    CharacterEpisodeStatus["NONE"] = "None";
    CharacterEpisodeStatus["FIRST"] = "First";
    CharacterEpisodeStatus["SECOND"] = "Second";
})(CharacterEpisodeStatus || (CharacterEpisodeStatus = {}));

class CharacterCalculator {
    dataProvider;
    characterBloomService;
    characterEpisodeService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.characterBloomService = new CharacterBloomService(dataProvider);
        this.characterEpisodeService = new CharacterEpisodeService(dataProvider);
    }
    async getCharacterLevel(level) {
        const levels = await this.dataProvider.getMasterData('characterLevel');
        return findOrThrow(levels, it => it.level === level);
    }
    async getMaxCharacterLevel() {
        const levels = await this.dataProvider.getMasterData('characterLevel');
        return levels.filter(it => siriusTimestampToDate(it.startDate).getTime() <= Date.now())
            .reduce((max, it) => Math.max(max, it.level), 0);
    }
    static getEpisodeBonus(episode) {
        switch (episode) {
            case CharacterEpisodeStatus.NONE:
                return 0;
            case CharacterEpisodeStatus.FIRST:
                return 2;
            case CharacterEpisodeStatus.SECOND:
                return 5;
        }
    }
    static getStatus(baseValue, storyReadBonus, characterLevelFactor, awakeningPhase = 0, baseCorrectionEffectPercent = 0, starRankPercent = 0) {
        const status = characterLevelFactor /
            100.0 *
            (storyReadBonus + baseValue) *
            ((baseCorrectionEffectPercent / 100.0 + Math.fround(Math.fround(awakeningPhase) * 10.0) +
                100.0 + starRankPercent) / 100.0);
        return Math.floor(status);
    }
    async getCharacterStatus(character, { level = 1, awakening = false, episode = CharacterEpisodeStatus.NONE, bloom = 0 }) {
        const storyReadBonus = CharacterCalculator.getEpisodeBonus(episode);
        const characterLevelFactor = (await this.getCharacterLevel(level)).characterStatusLevel;
        const awakenPhase = awakening ? 1 : 0;
        const baseCorrectionEffectPercent = await this.characterBloomService
            .getBloomBonusTotal(character.bloomBonusGroupMasterId, 'BaseCorrection', bloom);
        return {
            preset: {
                level,
                awakening,
                episode,
                bloom
            },
            status: {
                vocal: CharacterCalculator.getStatus(character.minLevelStatus.vocal, storyReadBonus, characterLevelFactor, awakenPhase, baseCorrectionEffectPercent),
                expression: CharacterCalculator.getStatus(character.minLevelStatus.expression, storyReadBonus, characterLevelFactor, awakenPhase, baseCorrectionEffectPercent),
                concentration: CharacterCalculator
                    .getStatus(character.minLevelStatus.concentration, storyReadBonus, characterLevelFactor, awakenPhase, baseCorrectionEffectPercent)
            }
        };
    }
    async getMinCharacterStatus(character) {
        return await this.getCharacterStatus(character, {});
    }
    async getMaxCharacterStatus(character) {
        return await this.getCharacterStatus(character, {
            level: await this.getMaxCharacterLevel(),
            awakening: character.characterAwakeningItemGroupMasterId !== undefined,
            episode: await this.characterEpisodeService.getCharacterMaxEpisodeStatus(character.id),
            bloom: 5
        });
    }
}

class GachaService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getGachaes() {
        return await this.dataProvider.getMasterData('gacha');
    }
    async getGacha(id) {
        return await this.dataProvider.getMasterDataById('gacha', id);
    }
    async getGachaTextTemplate(id) {
        return await this.dataProvider.getMasterDataById('gachaTextTemplate', id);
    }
    async getGachaType(gacha) {
        const description = (await this.getGachaTextTemplate(gacha.gachaTextTemplateMasterId)).description;
        if (gacha.name.includes('ユメフェスガチャ')) {
            return GachaType.FESTIVAL_LIMITED;
        }
        if (gacha.name.includes('復刻')) {
            return GachaType.LIMITED_REOPEN;
        }
        if (gacha.name.includes('★4セレクトピックアップガチャ')) {
            return GachaType.SELECT_PICKUP;
        }
        if (gacha.name.includes('ピックアップガチャ')) {
            return GachaType.PICKUP;
        }
        if (gacha.name.includes('10連ガチャ')) {
            return GachaType.FREE;
        }
        if (description.includes('コラボ限定')) {
            return GachaType.CLUB_LIMITED;
        }
        if (description.includes('期間限定')) {
            return GachaType.TIME_LIMITED;
        }
        return GachaType.NORMAL;
    }
    async getGachaDetail(id) {
        const gacha = await this.getGacha(id);
        return {
            id: gacha.id,
            name: gacha.name,
            cardType: gacha.cardType,
            startDate: siriusTimestampToDate(gacha.startDate),
            type: await this.getGachaType(gacha)
        };
    }
    async getFirstAppearGacha(cardType, thingId, notAfterTime = Date.now()) {
        const gachaes = (await this.getGachaes()).filter(it => it.cardType === cardType)
            .sort((a, b) => a.startDate - b.startDate);
        for (const gacha of gachaes) {
            if (gacha.startDate > notAfterTime)
                break;
            if (gacha.things.find(it => it.thingId === thingId) !== undefined) {
                return await this.getGachaDetail(gacha.id);
            }
        }
        return {
            name: '无',
            type: GachaType.NONE
        };
    }
    async getCharacterFirstAppearGacha(characterId, notAfterTime = Date.now()) {
        return await this.getFirstAppearGacha('Character', characterId, notAfterTime);
    }
    async getPosterFirstAppearGacha(posterId, notAfterTime = Date.now()) {
        return await this.getFirstAppearGacha('Poster', posterId, notAfterTime);
    }
}
var GachaType;
(function (GachaType) {
    GachaType["NONE"] = "None";
    GachaType["NORMAL"] = "Normal";
    GachaType["TIME_LIMITED"] = "TimeLimited";
    GachaType["FESTIVAL_LIMITED"] = "FestivalLimited";
    GachaType["CLUB_LIMITED"] = "ClubLimited";
    GachaType["LIMITED_REOPEN"] = "LimitedReopen";
    GachaType["PICKUP"] = "Pickup";
    GachaType["SELECT_PICKUP"] = "SelectPickup";
    GachaType["FREE"] = "Free";
})(GachaType || (GachaType = {}));

class StoryEventService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getStoryEvents() {
        return await this.dataProvider.getMasterData('storyEvent');
    }
    async getStoryEvent(id) {
        return await this.dataProvider.getMasterDataById('storyEvent', id);
    }
    async getStoryEventDetail(id) {
        const event = await this.getStoryEvent(id);
        return {
            id: event.id,
            title: event.title
        };
    }
    async getFirstAppearStoryEvent(displayStartAt) {
        const events = await this.getStoryEvents();
        const event = events
            .find(it => it.startDate <= displayStartAt && displayStartAt < it.forceEndDate);
        if (event !== undefined) {
            return await this.getStoryEventDetail(event.id);
        }
        return {
            title: '无'
        };
    }
}

class CharacterService {
    dataProvider;
    characterBaseService;
    starActService;
    senseService;
    characterBloomService;
    storyEventService;
    gachaService;
    characterEpisodeService;
    characterCalculator;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.characterBaseService = new CharacterBaseService(dataProvider);
        this.starActService = new StarActService(dataProvider);
        this.senseService = new SenseService(dataProvider);
        this.characterBloomService = new CharacterBloomService(dataProvider);
        this.storyEventService = new StoryEventService(dataProvider);
        this.gachaService = new GachaService(dataProvider);
        this.characterEpisodeService = new CharacterEpisodeService(dataProvider);
        this.characterCalculator = new CharacterCalculator(dataProvider);
    }
    async getCharacters() {
        return await this.dataProvider.getMasterData('character');
    }
    async getCharacter(id) {
        return await this.dataProvider.getMasterDataById('character', id);
    }
    async getCharacterDetail(id) {
        const character = await this.getCharacter(id);
        const event = await this.storyEventService.getFirstAppearStoryEvent(character.displayStartAt);
        const gacha = await this.gachaService.getCharacterFirstAppearGacha(character.id, character.displayStartAt);
        return {
            id: character.id,
            name: character.name,
            rarity: character.rarity,
            attribute: character.attribute,
            status: [await this.characterCalculator.getMinCharacterStatus(character),
                await this.characterCalculator.getMaxCharacterStatus(character)],
            characterBase: await this.characterBaseService.getCharacterBaseName(character.characterBaseMasterId),
            characterBaseChinese: characterBaseChineseNames[character.id],
            starAct: await this.starActService.getStarActDetail(character.starActMasterId, character.bloomBonusGroupMasterId),
            sense: await this.senseService.getSenseDetail(character.senseMasterId, character.bloomBonusGroupMasterId),
            bloomBonuses: await this.characterBloomService.getBloomBonusDetails(character.bloomBonusGroupMasterId),
            displayStartAt: siriusTimestampToDate(character.displayStartAt),
            event: event.title,
            gacha: gacha.name,
            type: gacha.type,
            episodes: await this.characterEpisodeService.getCharacterEpisodeDetails(character.id)
        };
    }
    async getAllCharacterDetails() {
        const characters = await this.getCharacters();
        return await Promise.all(characters.map(async (it) => await this.getCharacterDetail(it.id)));
    }
}

class PosterLevelPatternGroupService {
    dataProvider;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
    }
    async getPosterLevelPatternGroup(id) {
        return await this.dataProvider.getMasterDataById('posterLevelPatternGroup', id);
    }
    async getPosterLevelMax(id) {
        const group = await this.getPosterLevelPatternGroup(id);
        const maxLevel = group.patterns.map(it => it.level)
            .reduce((pre, it) => Math.max(pre, it));
        return maxLevel + 5;
    }
}

class PosterAbilityService {
    dataProvider;
    effectService;
    posterLevelPatternGroupService;
    translationService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.effectService = new EffectService(dataProvider);
        this.posterLevelPatternGroupService = new PosterLevelPatternGroupService(dataProvider);
        this.translationService = TranslationService.getInstance();
    }
    async getPosterAbilities(posterId) {
        const posterAbilities = await this.dataProvider.getMasterData('posterAbility');
        return posterAbilities.filter(it => it.posterMasterId === posterId);
    }
    async getPosterAbilityDescription(description, posterAbility, maxLevel) {
        for (let i = 0; i < posterAbility.branches.length; ++i) {
            const branch = posterAbility.branches[i];
            for (let j = 0; j < branch.branchEffects.length; ++j) {
                const effect = branch.branchEffects[j];
                description = description.replaceAll(`[:param${i + 1}${j + 1}]`, await this.effectService.getEffectRange(effect.effectMasterId, 1, maxLevel));
            }
        }
        return description;
    }
    async getPosterAbilityEffectDetails(posterAbility, maxLevel) {
        const ret = [];
        for (const branch of posterAbility.branches) {
            for (const effect of branch.branchEffects) {
                ret.push(await this.effectService.getEffectDetails(effect.effectMasterId, maxLevel));
            }
        }
        return ret;
    }
    getDescriptionTranslation(description) {
        const descriptions = description.split('　◆発動条件：');
        return descriptions.map(it => this.translationService.getChineseTranslation(it)).join('　◆发动条件：');
    }
    async getPosterAbilityDetails(poster) {
        const posterAbilities = await this.getPosterAbilities(poster.id);
        const maxLevel = await this.posterLevelPatternGroupService.getPosterLevelMax(poster.levelPatternGroupMasterId);
        return await Promise.all(posterAbilities.map(async (it) => {
            return {
                name: it.name,
                description: await this.getPosterAbilityDescription(it.description, it, maxLevel),
                descriptionChinese: await this.getPosterAbilityDescription(this.getDescriptionTranslation(it.description), it, maxLevel),
                effectDetails: await this.getPosterAbilityEffectDetails(it, maxLevel),
                type: it.type,
                releaseLevelAt: it.releaseLevelAt
            };
        }));
    }
}

class PosterService {
    dataProvider;
    characterBaseService;
    posterAbilityService;
    storyEventService;
    gachaService;
    constructor(dataProvider = DataProviderFactory.defaultDataProvider()) {
        this.dataProvider = dataProvider;
        this.characterBaseService = new CharacterBaseService(dataProvider);
        this.posterAbilityService = new PosterAbilityService(dataProvider);
        this.storyEventService = new StoryEventService(dataProvider);
        this.gachaService = new GachaService(dataProvider);
    }
    async getPosters() {
        return await this.dataProvider.getMasterData('poster');
    }
    async getPoster(id) {
        return await this.dataProvider.getMasterDataById('poster', id);
    }
    async getPosterDetail(id) {
        const poster = await this.getPoster(id);
        const event = await this.storyEventService.getFirstAppearStoryEvent(poster.displayStartAt);
        const gacha = await this.gachaService.getPosterFirstAppearGacha(poster.id, poster.displayStartAt);
        return {
            id: poster.id,
            name: poster.name,
            rarity: poster.rarity,
            pronounceName: poster.pronounceName,
            appearanceCharacterBases: await Promise.all(poster.appearanceCharacterBaseMasterIds
                .map(async (it) => await this.characterBaseService.getCharacterBaseName(it))),
            appearanceCharacterBasesChinese: poster.appearanceCharacterBaseMasterIds
                .map(it => characterBaseChineseNames[it]),
            displayStartAt: siriusTimestampToDate(poster.displayStartAt),
            abilities: await this.posterAbilityService.getPosterAbilityDetails(poster),
            event: event.title,
            gacha: gacha.name,
            type: gacha.type
        };
    }
    async getAllPosterDetails() {
        const posters = await this.getPosters();
        return await Promise.all(posters.map(async (it) => await this.getPosterDetail(it.id)));
    }
}

class GithubDataProvider extends UrlDataProvider {
    getUrl(key) {
        return `https://raw.githubusercontent.com/xfl03/sirius-master/main/${key}.json`;
    }
}

export { CachedDataProvider, CharacterCalculator, CharacterService, CloudFlareDataProvider, DataProvider, GithubDataProvider, PosterService, UrlDataProvider };

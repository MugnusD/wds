declare abstract class DataProvider {
    abstract getMasterData<T>(key: string): Promise<T[]>;
    getMasterDataById<T extends HasId>(key: string, id: number): Promise<T>;
}
interface HasId {
    id: number;
}

interface BloomBonusDetail {
    phase: number;
    descriptions: string[];
    descriptionsChinese: string[];
}

interface SenseDetail {
    descriptions: string[];
    descriptionsChinese: string[];
    type: string;
    lightCount: number;
    acquirableGauge: number;
    coolTime: {
        origin: number;
        bloom: number;
    };
    effectTypes: string[];
}

interface StarActDetail {
    description: string;
    descriptionChinese: string;
    conditions: StarActLightCondition[];
}
interface StarActLightCondition {
    type: string;
    typeChinese: string;
    origin: number;
    bloom: number;
}

interface Character {
    id: number;
    characterBaseMasterId: number;
    name: string;
    description: string;
    rarity: string;
    attribute: string;
    minLevelStatus: {
        vocal: number;
        expression: number;
        concentration: number;
    };
    starActMasterId: number;
    senseMasterId: number;
    forbidGenericItemBloom: boolean;
    bloomBonusGroupMasterId: number;
    senseEnhanceItemGroupMasterId: number;
    firstEpisodeReleaseItemGroupId: number;
    secondEpisodeReleaseItemGroupId: number;
    characterAwakeningItemGroupMasterId?: number;
    displayStartAt: number;
    displayEndAt: number;
}

interface CharacterEpisodeDetail {
    id: number;
    episodeOrder: string;
}
declare enum CharacterEpisodeStatus {
    NONE = "None",
    FIRST = "First",
    SECOND = "Second"
}

declare class CharacterCalculator {
    private readonly dataProvider;
    private readonly characterBloomService;
    private readonly characterEpisodeService;
    constructor(dataProvider?: DataProvider);
    private getCharacterLevel;
    private getMaxCharacterLevel;
    private static getEpisodeBonus;
    private static getStatus;
    getCharacterStatus(character: Character, { level, awakening, episode, bloom }: CharacterStatusPreset): Promise<CharacterStatusDetail>;
    getMinCharacterStatus(character: Character): Promise<CharacterStatusDetail>;
    getMaxCharacterStatus(character: Character): Promise<CharacterStatusDetail>;
}
interface CharacterStatusPreset {
    level?: number;
    awakening?: boolean;
    episode?: CharacterEpisodeStatus;
    bloom?: number;
}
interface CharacterStatusDetail {
    preset: CharacterStatusPreset;
    status: {
        vocal: number;
        expression: number;
        concentration: number;
    };
}

declare enum GachaType {
    NONE = "None",
    NORMAL = "Normal",
    TIME_LIMITED = "TimeLimited",
    FESTIVAL_LIMITED = "FestivalLimited",
    CLUB_LIMITED = "ClubLimited",
    LIMITED_REOPEN = "LimitedReopen",
    PICKUP = "Pickup",
    SELECT_PICKUP = "SelectPickup",
    FREE = "Free"
}

declare class CharacterService {
    private readonly dataProvider;
    private readonly characterBaseService;
    private readonly starActService;
    private readonly senseService;
    private readonly characterBloomService;
    private readonly storyEventService;
    private readonly gachaService;
    private readonly characterEpisodeService;
    private readonly characterCalculator;
    constructor(dataProvider?: DataProvider);
    private getCharacters;
    private getCharacter;
    getCharacterDetail(id: number): Promise<CharacterDetail>;
    getAllCharacterDetails(): Promise<CharacterDetail[]>;
}
interface CharacterDetail {
    id: number;
    name: string;
    rarity: string;
    attribute: string;
    status: CharacterStatusDetail[];
    characterBase: string;
    characterBaseChinese: string;
    starAct: StarActDetail;
    sense: SenseDetail;
    bloomBonuses: BloomBonusDetail[];
    displayStartAt: Date;
    event: string;
    gacha: string;
    type: GachaType;
    episodes: CharacterEpisodeDetail[];
}

interface PosterAbilityDetail {
    name: string;
    description: string;
    descriptionChinese: string;
    effectDetails: number[][];
    type: string;
    releaseLevelAt: number;
}

declare class PosterService {
    private readonly dataProvider;
    private readonly characterBaseService;
    private readonly posterAbilityService;
    private readonly storyEventService;
    private readonly gachaService;
    constructor(dataProvider?: DataProvider);
    private getPosters;
    private getPoster;
    getPosterDetail(id: number): Promise<PosterDetail>;
    getAllPosterDetails(): Promise<PosterDetail[]>;
}
interface PosterDetail {
    id: number;
    name: string;
    rarity: string;
    pronounceName: string;
    appearanceCharacterBases: string[];
    appearanceCharacterBasesChinese: string[];
    displayStartAt: Date;
    abilities: PosterAbilityDetail[];
    event: string;
    gacha: string;
    type: GachaType;
}

declare class CachedDataProvider extends DataProvider {
    private readonly dataProvider;
    constructor(dataProvider: DataProvider);
    private static readonly globalCache;
    private static readonly runningPromise;
    private getData;
    getMasterData<T>(key: string): Promise<T[]>;
    private static readonly idMapCache;
    getMasterDataById<T extends HasId>(key: string, id: number): Promise<T>;
}

declare abstract class UrlDataProvider extends DataProvider {
    getMasterData<T>(key: string): Promise<T[]>;
    protected abstract getUrl(key: string): string;
}

declare class CloudFlareDataProvider extends UrlDataProvider {
    protected getUrl(key: string): string;
}

declare class GithubDataProvider extends UrlDataProvider {
    protected getUrl(key: string): string;
}

export { CachedDataProvider, CharacterCalculator, CharacterService, type CharacterStatusDetail, type CharacterStatusPreset, CloudFlareDataProvider, DataProvider, GithubDataProvider, type HasId, PosterService, UrlDataProvider };
